From 65ed2ffd640578166e4ec149573bcf1d10f81b81 Mon Sep 17 00:00:00 2001
From: "Mintz, Yuval" <Yuval.Mintz@cavium.com>
Date: Mon, 20 Feb 2017 22:43:39 +0200
Subject: [PATCH 154/154] qed*: Fix link indication race

Driver changes the link properties via communication with
the management firmware, and re-reads the resulting link status
when it receives an indication that the link has changed.
However, there are certain scenarios where such indications
might be missing, and so driver also re-reads the current link
results without attention in several places. Specifically, it
does so during load and when resetting the link.

This creates a race where driver might reflect incorrect
link status - e.g., when explicit reading of the link status is
switched by attention with the changed configuration.

Correct this flow by a lock syncronizing the handling of the
link indications [both explicit requests and attention].

Signed-off-by: Yuval Mintz <Yuval.Mintz@cavium.com>
Signed-off-by: David S. Miller <davem@davemloft.net>
---
 drivers/net/ethernet/qlogic/qed/qed_main.c   | 12 +++++++++---
 drivers/net/ethernet/qlogic/qed/qed_mcp.c    | 18 ++++++++++++++----
 drivers/net/ethernet/qlogic/qed/qed_mcp.h    |  6 ++++++
 drivers/net/ethernet/qlogic/qed/qed_sriov.h  |  1 +
 drivers/net/ethernet/qlogic/qed/qed_vf.c     |  3 +++
 drivers/net/ethernet/qlogic/qede/qede_main.c |  5 -----
 6 files changed, 33 insertions(+), 12 deletions(-)

Index: compat-rdma-work/drivers/net/ethernet/qlogic/qed/qed_main.c
===================================================================
--- compat-rdma-work.orig/drivers/net/ethernet/qlogic/qed/qed_main.c
+++ compat-rdma-work/drivers/net/ethernet/qlogic/qed/qed_main.c
@@ -1135,12 +1135,18 @@ static int qed_set_link(struct qed_dev *
	if (!cdev)
		return -ENODEV;

-	if (IS_VF(cdev))
-		return 0;
-
	/* The link should be set only once per PF */
	hwfn = &cdev->hwfns[0];

+	/* When VF wants to set link, force it to read the bulletin instead.
+	 * This mimics the PF behavior, where a noitification [both immediate
+	 * and possible later] would be generated when changing properties.
+	 */
+	if (IS_VF(cdev)) {
+		qed_schedule_iov(hwfn, QED_IOV_WQ_VF_FORCE_LINK_QUERY_FLAG);
+		return 0;
+	}
+
	ptt = qed_ptt_acquire(hwfn);
	if (!ptt)
		return -EBUSY;
Index: compat-rdma-work/drivers/net/ethernet/qlogic/qed/qed_mcp.c
===================================================================
--- compat-rdma-work.orig/drivers/net/ethernet/qlogic/qed/qed_mcp.c
+++ compat-rdma-work/drivers/net/ethernet/qlogic/qed/qed_mcp.c
@@ -192,6 +192,7 @@ int qed_mcp_cmd_init(struct qed_hwfn *p_

	/* Initialize the MFW spinlock */
	spin_lock_init(&p_info->lock);
+	spin_lock_init(&p_info->link_lock);

	return 0;

@@ -610,6 +611,9 @@ static void qed_mcp_handle_link_change(s
	u8 max_bw, min_bw;
	u32 status = 0;

+	/* Prevent SW/attentions from doing this at the same time */
+	spin_lock_bh(&p_hwfn->mcp_info->link_lock);
+
	p_link = &p_hwfn->mcp_info->link_output;
	memset(p_link, 0, sizeof(*p_link));
	if (!b_reset) {
@@ -624,7 +628,7 @@ static void qed_mcp_handle_link_change(s
	} else {
		DP_VERBOSE(p_hwfn, NETIF_MSG_LINK,
			   "Resetting link indications\n");
-		return;
+		goto out;
	}

	if (p_hwfn->b_drv_link_init)
@@ -731,6 +735,8 @@ static void qed_mcp_handle_link_change(s
	p_link->sfp_tx_fault = !!(status & LINK_STATUS_SFP_TX_FAULT);

	qed_link_update(p_hwfn);
+out:
+	spin_unlock_bh(&p_hwfn->mcp_info->link_lock);
 }

 int qed_mcp_set_link(struct qed_hwfn *p_hwfn, struct qed_ptt *p_ptt, bool b_up)
@@ -780,9 +786,13 @@ int qed_mcp_set_link(struct qed_hwfn *p_
		return rc;
	}

-	/* Reset the link status if needed */
-	if (!b_up)
-		qed_mcp_handle_link_change(p_hwfn, p_ptt, true);
+	/* Mimic link-change attention, done for several reasons:
+	 *  - On reset, there's no guarantee MFW would trigger
+	 *    an attention.
+	 *  - On initialization, older MFWs might not indicate link change
+	 *    during LFA, so we'll never get an UP indication.
+	 */
+	qed_mcp_handle_link_change(p_hwfn, p_ptt, !b_up);

	return 0;
 }
Index: compat-rdma-work/drivers/net/ethernet/qlogic/qed/qed_mcp.h
===================================================================
--- compat-rdma-work.orig/drivers/net/ethernet/qlogic/qed/qed_mcp.h
+++ compat-rdma-work/drivers/net/ethernet/qlogic/qed/qed_mcp.h
@@ -485,7 +485,13 @@ int qed_mcp_bist_nvm_test_get_image_att(
 #define MFW_PORT(_p_hwfn)       ((_p_hwfn)->abs_pf_id %	\
				 ((_p_hwfn)->cdev->num_ports_in_engines * 2))
 struct qed_mcp_info {
+	/* Spinlock used for protecting the access to the MFW mailbox */
	spinlock_t				lock;
+
+	/* Spinlock used for syncing SW link-changes and link-changes
+	 * originating from attention context.
+	 */
+	spinlock_t				link_lock;
	bool					block_mb_sending;
	u32					public_base;
	u32					drv_mb_addr;
Index: compat-rdma-work/drivers/net/ethernet/qlogic/qed/qed_sriov.h
===================================================================
--- compat-rdma-work.orig/drivers/net/ethernet/qlogic/qed/qed_sriov.h
+++ compat-rdma-work/drivers/net/ethernet/qlogic/qed/qed_sriov.h
@@ -228,6 +228,7 @@ enum qed_iov_wq_flag {
	QED_IOV_WQ_BULLETIN_UPDATE_FLAG,
	QED_IOV_WQ_STOP_WQ_FLAG,
	QED_IOV_WQ_FLR_FLAG,
+	QED_IOV_WQ_VF_FORCE_LINK_QUERY_FLAG
 };

 #ifdef CONFIG_QED_SRIOV
Index: compat-rdma-work/drivers/net/ethernet/qlogic/qed/qed_vf.c
===================================================================
--- compat-rdma-work.orig/drivers/net/ethernet/qlogic/qed/qed_vf.c
+++ compat-rdma-work/drivers/net/ethernet/qlogic/qed/qed_vf.c
@@ -1279,6 +1279,9 @@ void qed_iov_vf_task(struct work_struct

	/* Handle bulletin board changes */
	qed_vf_read_bulletin(hwfn, &change);
+	if (test_and_clear_bit(QED_IOV_WQ_VF_FORCE_LINK_QUERY_FLAG,
+			       &hwfn->iov_task_flags))
+		change = 1;
	if (change)
		qed_handle_bulletin_change(hwfn);

Index: compat-rdma-work/drivers/net/ethernet/qlogic/qede/qede_main.c
===================================================================
--- compat-rdma-work.orig/drivers/net/ethernet/qlogic/qede/qede_main.c
+++ compat-rdma-work/drivers/net/ethernet/qlogic/qede/qede_main.c
@@ -1773,7 +1773,6 @@ enum qede_load_mode {
 static int qede_load(struct qede_dev *edev, enum qede_load_mode mode)
 {
	struct qed_link_params link_params;
-	struct qed_link_output link_output;
	int rc;

	DP_INFO(edev, "Starting qede load\n");
@@ -1826,11 +1825,7 @@ static int qede_load(struct qede_dev *ed
	link_params.link_up = true;
	edev->ops->common->set_link(edev->cdev, &link_params);

-	/* Query whether link is already-up */
-	memset(&link_output, 0, sizeof(link_output));
-	edev->ops->common->get_link(edev->cdev, &link_output);
	qede_roce_dev_event_open(edev);
-	qede_link_update(edev, &link_output);

	qede_ptp_start(edev, (mode == QEDE_LOAD_NORMAL));
