From 1fafac5794817725b34192e69e6229784d6514f8 Mon Sep 17 00:00:00 2001
From: root <root@stevo3.asicdesigners.com>
Date: Tue, 11 Oct 2016 15:55:07 -0700
Subject: BACKPORT: cxgb4

Signed-off-by: Steve Wise <swise@opengridcomputing.com>
---
 drivers/infiniband/hw/cxgb4/Makefile               |   2 +-
 drivers/net/ethernet/chelsio/cxgb4/clip_tbl.c      |  19 ++
 drivers/net/ethernet/chelsio/cxgb4/cxgb4_debugfs.c |  15 +-
 drivers/net/ethernet/chelsio/cxgb4/cxgb4_ethtool.c | 255 ++++++++++++++++++++-
 drivers/net/ethernet/chelsio/cxgb4/cxgb4_main.c    |  39 +++-
 drivers/net/ethernet/chelsio/cxgb4/sge.c           |  12 +
 drivers/net/ethernet/chelsio/cxgb4/t4_hw.c         |   8 +-
 7 files changed, 340 insertions(+), 10 deletions(-)

diff --git a/drivers/infiniband/hw/cxgb4/Makefile b/drivers/infiniband/hw/cxgb4/Makefile
index e11cf72..2f9fbf3 100644
--- a/drivers/infiniband/hw/cxgb4/Makefile
+++ b/drivers/infiniband/hw/cxgb4/Makefile
@@ -1,4 +1,4 @@
-ccflags-y := -Idrivers/net/ethernet/chelsio/cxgb4
+ccflags-y := -I$(CWD)/drivers/net/ethernet/chelsio/cxgb4
 
 obj-$(CONFIG_INFINIBAND_CXGB4) += iw_cxgb4.o
 
diff --git a/drivers/net/ethernet/chelsio/cxgb4/clip_tbl.c b/drivers/net/ethernet/chelsio/cxgb4/clip_tbl.c
index 7ad43af..5e2873a 100644
--- a/drivers/net/ethernet/chelsio/cxgb4/clip_tbl.c
+++ b/drivers/net/ethernet/chelsio/cxgb4/clip_tbl.c
@@ -237,7 +237,26 @@ int cxgb4_update_root_dev_clip(struct net_device *dev)
 	}
 
 	for (i = 0; i < VLAN_N_VID; i++) {
+#ifdef HAVE___VLAN_FIND_DEV_DEEP_RCU
 		root_dev = __vlan_find_dev_deep_rcu(dev, htons(ETH_P_8021Q), i);
+#else
+#ifdef HAVE__VLAN_FIND_DEV_DEEP_3P
+		root_dev = __vlan_find_dev_deep(dev, htons(ETH_P_8021Q), i);
+#else
+#ifdef HAVE__VLAN_FIND_DEV_DEEP
+		root_dev = __vlan_find_dev_deep(dev, i);
+#else
+	{
+		struct port_info *p = netdev_priv(dev);
+
+		if (p->vlan_grp)
+			root_dev = vlan_group_get_device(p->vlan_grp, i);
+		else
+			root_dev = NULL;
+	}
+#endif
+#endif
+#endif
 		if (!root_dev)
 			continue;
 
diff --git a/drivers/net/ethernet/chelsio/cxgb4/cxgb4_debugfs.c b/drivers/net/ethernet/chelsio/cxgb4/cxgb4_debugfs.c
index 91fb508..ed4f506 100644
--- a/drivers/net/ethernet/chelsio/cxgb4/cxgb4_debugfs.c
+++ b/drivers/net/ethernet/chelsio/cxgb4/cxgb4_debugfs.c
@@ -2931,8 +2931,13 @@ static void mem_region_show(struct seq_file *seq, const char *name,
 {
 	char buf[40];
 
+#ifdef HAVE_STRING_GET_SIZE_5_PARAMS
 	string_get_size((u64)to - from + 1, 1, STRING_UNITS_2, buf,
 			sizeof(buf));
+#else
+	string_get_size((u64)to - from + 1, STRING_UNITS_2, buf,
+			sizeof(buf));
+#endif
 	seq_printf(seq, "%-15s %#x-%#x [%s]\n", name, from, to, buf);
 }
 
@@ -3319,10 +3324,16 @@ int t4_setup_debugfs(struct adapter *adap)
 
 	de = debugfs_create_file_size("flash", S_IRUSR, adap->debugfs_root, adap,
 				      &flash_debugfs_fops, adap->params.sf_size);
+
+#ifdef HAVE_DEBUGFS_CREATE_BOOL_USES_BOOL_PTR
+#define __CAST
+#else
+#define __CAST (u32 *)
+#endif
 	debugfs_create_bool("use_backdoor", S_IWUSR | S_IRUSR,
-			    adap->debugfs_root, &adap->use_bd);
+			    adap->debugfs_root, __CAST &adap->use_bd);
 	debugfs_create_bool("trace_rss", S_IWUSR | S_IRUSR,
-			    adap->debugfs_root, &adap->trace_rss);
+			    adap->debugfs_root, __CAST &adap->trace_rss);
 
 	return 0;
 }
diff --git a/drivers/net/ethernet/chelsio/cxgb4/cxgb4_ethtool.c b/drivers/net/ethernet/chelsio/cxgb4/cxgb4_ethtool.c
index 02f80fe..fef162d 100644
--- a/drivers/net/ethernet/chelsio/cxgb4/cxgb4_ethtool.c
+++ b/drivers/net/ethernet/chelsio/cxgb4/cxgb4_ethtool.c
@@ -201,6 +201,12 @@ static int get_eeprom_len(struct net_device *dev)
 	return EEPROMSIZE;
 }
 
+#ifdef HAVE_ETHTOOL_DRVINFO_EROM_VERSION
+#define __EROM_VERSION erom_version
+#else
+#define __EROM_VERSION reserved1
+#endif
+
 static void get_drvinfo(struct net_device *dev, struct ethtool_drvinfo *info)
 {
 	struct adapter *adapter = netdev2adap(dev);
@@ -228,7 +234,7 @@ static void get_drvinfo(struct net_device *dev, struct ethtool_drvinfo *info)
 			 FW_HDR_FW_VER_BUILD_G(adapter->params.tp_vers));
 
 	if (!t4_get_exprom_version(adapter, &exprom_vers))
-		snprintf(info->erom_version, sizeof(info->erom_version),
+		snprintf(info->__EROM_VERSION, sizeof(info->__EROM_VERSION),
 			 "%u.%u.%u.%u",
 			 FW_HDR_FW_VER_MAJOR_G(exprom_vers),
 			 FW_HDR_FW_VER_MINOR_G(exprom_vers),
@@ -540,6 +546,221 @@ static unsigned int speed_to_fw_caps(int speed)
 	return 0;
 }
 
+#ifndef HAVE___ETHTOOL_GET_LINK_KSETTINGS
+
+/**
+ *	fw_caps_to_et_caps - translate Firmware to old-style ethtool capabilities
+ *	@port_type: Firmware Port Type
+ *	@fw_caps: Firmware Port Capabilities
+ *
+ *	Translate a Firmware Port Capabilities specification to an old-style
+ *	ethtool Port Capabilities value.
+ */
+static unsigned int fw_caps_to_et_caps(enum fw_port_type port_type,
+				       unsigned int fw_caps)
+{
+	unsigned int et_caps = 0;
+
+	switch (port_type) {
+	case FW_PORT_TYPE_BT_SGMII:
+	case FW_PORT_TYPE_BT_XFI:
+	case FW_PORT_TYPE_BT_XAUI:
+		et_caps |= SUPPORTED_TP;
+		if (fw_caps & FW_PORT_CAP_SPEED_100M)
+			et_caps |= SUPPORTED_100baseT_Full;
+		if (fw_caps & FW_PORT_CAP_SPEED_1G)
+			et_caps |= SUPPORTED_1000baseT_Full;
+		if (fw_caps & FW_PORT_CAP_SPEED_10G)
+			et_caps |= SUPPORTED_10000baseT_Full;
+		break;
+
+	case FW_PORT_TYPE_KX4:
+	case FW_PORT_TYPE_KX:
+		et_caps |= SUPPORTED_Backplane;
+		if (fw_caps & FW_PORT_CAP_SPEED_1G)
+			et_caps |= SUPPORTED_1000baseKX_Full;
+		if (fw_caps & FW_PORT_CAP_SPEED_10G)
+			et_caps |= SUPPORTED_10000baseKX4_Full;
+		break;
+
+	case FW_PORT_TYPE_KR:
+		et_caps |= SUPPORTED_Backplane | SUPPORTED_10000baseKR_Full;
+		break;
+
+	case FW_PORT_TYPE_BP_AP:
+		et_caps |= SUPPORTED_Backplane | SUPPORTED_10000baseR_FEC |
+		     SUPPORTED_10000baseKR_Full | SUPPORTED_1000baseKX_Full;
+		break;
+
+	case FW_PORT_TYPE_BP4_AP:
+		et_caps |= SUPPORTED_Backplane | SUPPORTED_10000baseR_FEC |
+		     SUPPORTED_10000baseKR_Full | SUPPORTED_1000baseKX_Full |
+		     SUPPORTED_10000baseKX4_Full;
+		break;
+
+	case FW_PORT_TYPE_FIBER_XFI:
+	case FW_PORT_TYPE_FIBER_XAUI:
+	case FW_PORT_TYPE_SFP:
+	case FW_PORT_TYPE_QSFP_10G:
+	case FW_PORT_TYPE_QSA:
+		et_caps |= SUPPORTED_FIBRE;
+		if (fw_caps & FW_PORT_CAP_SPEED_1G)
+			et_caps |= SUPPORTED_1000baseT_Full;
+		if (fw_caps & FW_PORT_CAP_SPEED_10G)
+			et_caps |= SUPPORTED_10000baseT_Full;
+		break;
+
+	case FW_PORT_TYPE_BP40_BA:
+	case FW_PORT_TYPE_QSFP:
+		et_caps |= SUPPORTED_FIBRE;
+		et_caps |= SUPPORTED_40000baseSR4_Full;
+		break;
+
+	case FW_PORT_TYPE_CR_QSFP:
+	case FW_PORT_TYPE_SFP28:
+		et_caps |= SUPPORTED_FIBRE;
+		/* legacy ethtool capabilities can't represent 25Gb/s */
+		break;
+        case FW_PORT_TYPE_KR4_100G:
+        case FW_PORT_TYPE_CR4_QSFP:
+		et_caps |= SUPPORTED_FIBRE;
+		/* legacy ethtool capabilities can't represent 100Gb/s */
+		break;
+	default:
+		break;
+	}
+
+	if (fw_caps & FW_PORT_CAP_ANEG)
+		et_caps |= SUPPORTED_Autoneg;
+
+	if (fw_caps & FW_PORT_CAP_802_3_PAUSE)
+		et_caps |= SUPPORTED_Pause;
+
+	if (fw_caps & FW_PORT_CAP_802_3_ASM_DIR)
+		et_caps |= SUPPORTED_Asym_Pause;
+
+	return et_caps;
+}
+
+/**
+ *	et_caps_to_fw_caps - translate old-style ethtool to Firmware capabilities
+ *	@et_caps: ethtool Port capabilities
+ *
+ *	Translate old-style ethtool Port Capabilities into a Firmware Port
+ *	capabilities value.  Note that legacy ethtool capabilities can't
+ *	represent 25/50/100Gb/s.
+ */
+static unsigned int et_caps_to_fw_caps(unsigned int et_caps)
+{
+	unsigned int fw_caps = 0;
+
+	if (et_caps & ADVERTISED_100baseT_Full)
+		fw_caps |= FW_PORT_CAP_SPEED_100M;
+	if (et_caps & ADVERTISED_1000baseT_Full)
+		fw_caps |= FW_PORT_CAP_SPEED_1G;
+	if (et_caps & ADVERTISED_10000baseT_Full)
+		fw_caps |= FW_PORT_CAP_SPEED_10G;
+	if (et_caps & ADVERTISED_40000baseSR4_Full)
+		fw_caps |= FW_PORT_CAP_SPEED_40G;
+
+	return fw_caps;
+}
+
+static int get_settings(struct net_device *dev, struct ethtool_cmd *cmd)
+{
+	const struct port_info *pi = netdev_priv(dev);
+
+	cmd->port = from_fw_port_mod_type(pi->port_type, pi->mod_type);
+
+	if (pi->mdio_addr >= 0) {
+		cmd->phy_address = pi->mdio_addr;
+		cmd->transceiver = XCVR_EXTERNAL;
+		cmd->mdio_support = (pi->port_type == FW_PORT_TYPE_BT_SGMII
+				     ? MDIO_SUPPORTS_C22
+				     : MDIO_SUPPORTS_C45);
+	} else {
+		cmd->phy_address = 0;  /* not really, but no better option */
+		cmd->transceiver = XCVR_INTERNAL;
+		cmd->mdio_support = 0;
+	}
+
+	cmd->supported = fw_caps_to_et_caps(pi->port_type,
+					    pi->link_cfg.supported);
+	cmd->advertising = fw_caps_to_et_caps(pi->port_type,
+					      pi->link_cfg.advertising);
+	if (pi->link_cfg.fc & PAUSE_RX) {
+		if (pi->link_cfg.fc & PAUSE_TX) {
+			cmd->advertising |= ADVERTISED_Pause;
+		} else {
+			cmd->advertising |= ADVERTISED_Pause |
+					    ADVERTISED_Asym_Pause;
+		}
+	} else if (pi->link_cfg.fc & PAUSE_TX) {
+		cmd->advertising |= ADVERTISED_Asym_Pause;
+	}
+	ethtool_cmd_speed_set(cmd,
+			      netif_carrier_ok(dev) ? pi->link_cfg.speed : 0);
+	cmd->duplex = DUPLEX_FULL;
+	cmd->autoneg = pi->link_cfg.autoneg;
+	cmd->maxtxpkt = 0;
+	cmd->maxrxpkt = 0;
+
+	return 0;
+}
+
+static int set_settings(struct net_device *dev, struct ethtool_cmd *cmd)
+{
+	struct port_info *pi = netdev_priv(dev);
+	struct link_config *lc = &pi->link_cfg;
+	u32 speed = ethtool_cmd_speed(cmd);
+	struct link_config old_lc;
+	unsigned int fw_caps;
+	int ret;
+
+	if (cmd->duplex != DUPLEX_FULL)     /* only full-duplex supported */
+		return -EINVAL;
+
+	if (!(lc->supported & FW_PORT_CAP_ANEG)) {
+		/*
+		 * PHY offers a single speed.  See if that's what's
+		 * being requested.
+		 */
+		if (cmd->autoneg == AUTONEG_DISABLE &&
+		    (lc->supported & speed_to_fw_caps(speed)))
+				return 0;
+		return -EINVAL;
+	}
+
+	old_lc = *lc;
+	if (cmd->autoneg == AUTONEG_DISABLE) {
+		fw_caps = speed_to_fw_caps(speed);
+
+		if (!(lc->supported & fw_caps))
+			return -EINVAL;
+		lc->requested_speed = fw_caps;
+		lc->advertising = 0;
+	} else {
+		fw_caps = et_caps_to_fw_caps(cmd->advertising);
+		if (!(lc->supported & fw_caps))
+			return -EINVAL;
+		lc->requested_speed = 0;
+		lc->advertising = fw_caps | FW_PORT_CAP_ANEG;
+	}
+	lc->autoneg = cmd->autoneg;
+
+	/*
+	 * If the firmware rejects the Link Configuration request, back out
+	 * the changes and report the error.
+	 */
+	ret = t4_link_l1cfg(pi->adapter, pi->adapter->mbox, pi->tx_chan, lc);
+	if (ret)
+		*lc = old_lc;
+
+	return ret;
+}
+
+#else /* HAVE___ETHTOOL_GET_LINK_KSETTINGS */
+
 /**
  *	fw_caps_to_lmm - translate Firmware to ethtool Link Mode Mask
  *	@port_type: Firmware Port Type
@@ -621,12 +842,13 @@ static void fw_caps_to_lmm(enum fw_port_type port_type,
 		SET_LMM(25000baseCR_Full);
 		break;
 
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(4,7,0)
 	case FW_PORT_TYPE_KR4_100G:
 	case FW_PORT_TYPE_CR4_QSFP:
 		SET_LMM(FIBRE);
 		SET_LMM(100000baseCR4_Full);
 		break;
-
+#endif
 	default:
 		break;
 	}
@@ -772,6 +994,7 @@ static int set_link_ksettings(struct net_device *dev,
 
 	return ret;
 }
+#endif /* HAVE___ETHTOOL_GET_LINK_KSETTINGS */
 
 static void get_pauseparam(struct net_device *dev,
 			   struct ethtool_pauseparam *epause)
@@ -1104,13 +1327,21 @@ static u32 get_rss_table_size(struct net_device *dev)
 	return pi->rss_size;
 }
 
-static int get_rss_table(struct net_device *dev, u32 *p, u8 *key, u8 *hfunc)
+#if defined(HAVE_GET_SET_RXFH) && !defined(HAVE_GET_SET_RXFH_INDIR_EXT)
+static int get_rss_table(struct net_device *dev, u32 *p,
+#ifdef HAVE_ETH_SS_RSS_HASH_FUNCS
+			 u8 *key, u8 *hfunc)
+#else
+			 u8 *key)
+#endif
 {
 	const struct port_info *pi = netdev_priv(dev);
 	unsigned int n = pi->rss_size;
 
+#ifdef HAVE_ETH_SS_RSS_HASH_FUNCS
 	if (hfunc)
 		*hfunc = ETH_RSS_HASH_TOP;
+#endif
 	if (!p)
 		return 0;
 	while (n--)
@@ -1118,18 +1349,24 @@ static int get_rss_table(struct net_device *dev, u32 *p, u8 *key, u8 *hfunc)
 	return 0;
 }
 
-static int set_rss_table(struct net_device *dev, const u32 *p, const u8 *key,
-			 const u8 hfunc)
+static int set_rss_table(struct net_device *dev, const u32 *p,
+#ifdef HAVE_ETH_SS_RSS_HASH_FUNCS
+			 const u8 *key, const u8 hfunc)
+#else
+			 const u8 *key)
+#endif
 {
 	unsigned int i;
 	struct port_info *pi = netdev_priv(dev);
 
+#ifdef HAVE_ETH_SS_RSS_HASH_FUNCS
 	/* We require at least one supported parameter to be changed and no
 	 * change in any of the unsupported parameters
 	 */
 	if (key ||
 	    (hfunc != ETH_RSS_HASH_NO_CHANGE && hfunc != ETH_RSS_HASH_TOP))
 		return -EOPNOTSUPP;
+#endif
 	if (!p)
 		return 0;
 
@@ -1143,6 +1380,7 @@ static int set_rss_table(struct net_device *dev, const u32 *p, const u8 *key,
 
 	return -EPERM;
 }
+#endif
 
 static int get_rxnfc(struct net_device *dev, struct ethtool_rxnfc *info,
 		     u32 *rules)
@@ -1208,8 +1446,13 @@ static int get_rxnfc(struct net_device *dev, struct ethtool_rxnfc *info,
 }
 
 static const struct ethtool_ops cxgb_ethtool_ops = {
+#ifndef HAVE___ETHTOOL_GET_LINK_KSETTINGS
+	.get_settings      = get_settings,
+	.set_settings      = set_settings,
+#else
 	.get_link_ksettings = get_link_ksettings,
 	.set_link_ksettings = set_link_ksettings,
+#endif
 	.get_drvinfo       = get_drvinfo,
 	.get_msglevel      = get_msglevel,
 	.set_msglevel      = set_msglevel,
@@ -1232,8 +1475,10 @@ static const struct ethtool_ops cxgb_ethtool_ops = {
 	.get_regs          = get_regs,
 	.get_rxnfc         = get_rxnfc,
 	.get_rxfh_indir_size = get_rss_table_size,
+#if defined(HAVE_GET_SET_RXFH) && !defined(HAVE_GET_SET_RXFH_INDIR_EXT)
 	.get_rxfh	   = get_rss_table,
 	.set_rxfh	   = set_rss_table,
+#endif
 	.flash_device      = set_flash,
 	.get_ts_info       = get_ts_info
 };
diff --git a/drivers/net/ethernet/chelsio/cxgb4/cxgb4_main.c b/drivers/net/ethernet/chelsio/cxgb4/cxgb4_main.c
index 3ceafb5..323525e 100644
--- a/drivers/net/ethernet/chelsio/cxgb4/cxgb4_main.c
+++ b/drivers/net/ethernet/chelsio/cxgb4/cxgb4_main.c
@@ -32,6 +32,9 @@
  * SOFTWARE.
  */
 
+#ifdef pr_fmt
+#undef pr_fmt
+#endif
 #define pr_fmt(fmt) KBUILD_MODNAME ": " fmt
 
 #include <linux/bitmap.h>
@@ -82,7 +85,7 @@ char cxgb4_driver_name[] = KBUILD_MODNAME;
 #ifdef DRV_VERSION
 #undef DRV_VERSION
 #endif
-#define DRV_VERSION "2.0.0-ko"
+#define DRV_VERSION "2.0.0-ofed"
 const char cxgb4_driver_version[] = DRV_VERSION;
 #define DRV_DESC "Chelsio T4/T5/T6 Network Driver"
 
@@ -1342,8 +1345,17 @@ static int del_filter_wr(struct adapter *adapter, int fidx)
 	return 0;
 }
 
+#ifdef HAVE_SELECT_QUEUE_FALLBACK_T
 static u16 cxgb_select_queue(struct net_device *dev, struct sk_buff *skb,
 			     void *accel_priv, select_queue_fallback_t fallback)
+#else
+#ifdef NDO_SELECT_QUEUE_HAS_ACCEL_PRIV
+static u16 cxgb_select_queue(struct net_device *dev, struct sk_buff *skb,
+			     void *accel_priv)
+#else
+#endif
+static u16 cxgb_select_queue(struct net_device *dev, struct sk_buff *skb)
+#endif
 {
 	int txq;
 
@@ -1385,7 +1397,11 @@ static u16 cxgb_select_queue(struct net_device *dev, struct sk_buff *skb,
 		return txq;
 	}
 
+#ifdef HAVE_SELECT_QUEUE_FALLBACK_T
 	return fallback(dev, skb) % dev->real_num_tx_queues;
+#else
+	return __netdev_pick_tx(dev, skb) % dev->real_num_tx_queues;
+#endif
 }
 
 static int closest_timer(const struct sge *s, int time)
@@ -3389,8 +3405,13 @@ static int adap_init0_phy(struct adapter *adap)
 	 * where we can load a PHY firmware file from the host if we want to
 	 * override the PHY firmware File in flash.
 	 */
+#ifdef HAVE_REQUEST_FIRMWARE_DIRECT
 	ret = request_firmware_direct(&phyf, phy_info->phy_fw_file,
 				      adap->pdev_dev);
+#else
+	ret = request_firmware(&phyf, phy_info->phy_fw_file,
+				      adap->pdev_dev);
+#endif
 	if (ret < 0) {
 		/* For adapters without FLASH attached to PHY for their
 		 * firmware, it's obviously a fatal error if we can't get the
@@ -4542,6 +4563,7 @@ static int enable_msix(struct adapter *adap)
 #else
 	need = adap->params.nports + EXTRA_VECS + ofld_need;
 #endif
+#ifdef HAVE_PCI_ENABLE_MSIX_RANGE
 	allocated = pci_enable_msix_range(adap->pdev, entries, need, want);
 	if (allocated < 0) {
 		dev_info(adap->pdev_dev, "not enough MSI-X vectors left,"
@@ -4549,7 +4571,22 @@ static int enable_msix(struct adapter *adap)
 		kfree(entries);
 		return allocated;
 	}
+#else
+{
+	int err;
+
+	while ((err = pci_enable_msix(adap->pdev, entries, want)) >= need)
+		want = err;
+	allocated = want;
 
+	if (err) {
+		if (err > 0)
+			dev_info(adap->pdev_dev, "only %d MSI-X vectors left, "
+				 "not using MSI-X\n", err);
+	return err;
+	}
+}
+#endif
 	/* Distribute available vectors to the various queue groups.
 	 * Every group gets its minimum requirement and NIC gets top
 	 * priority for leftovers.
diff --git a/drivers/net/ethernet/chelsio/cxgb4/sge.c b/drivers/net/ethernet/chelsio/cxgb4/sge.c
index ad3552d..8fea9ae 100644
--- a/drivers/net/ethernet/chelsio/cxgb4/sge.c
+++ b/drivers/net/ethernet/chelsio/cxgb4/sge.c
@@ -389,7 +389,11 @@ static void free_tx_desc(struct adapter *adap, struct sge_txq *q,
 		if (d->skb) {                       /* an SGL is present */
 			if (unmap)
 				unmap_sgl(dev, d->skb, d->sgl, q);
+#ifdef HAVE_DEV_CONSUME_SKB_ANY
 			dev_consume_skb_any(d->skb);
+#else
+			dev_kfree_skb_any(d->skb);
+#endif
 			d->skb = NULL;
 		}
 		++d;
@@ -1316,7 +1320,11 @@ out_free:	dev_kfree_skb_any(skb);
 
 	if (immediate) {
 		inline_tx_skb(skb, &q->q, cpl + 1);
+#ifdef HAVE_DEV_CONSUME_SKB_ANY
 		dev_consume_skb_any(skb);
+#else
+		dev_kfree_skb_any(skb);
+#endif
 	} else {
 		int last_desc;
 
@@ -2291,7 +2299,11 @@ static int napi_rx_handler(struct napi_struct *napi, int budget)
 	if (likely(work_done < budget)) {
 		int timer_index;
 
+#ifdef HAVE_NAPI_COMPLETE_DONE
 		napi_complete_done(napi, work_done);
+#else
+		napi_complete(napi);
+#endif
 		timer_index = QINTR_TIMER_IDX_G(q->next_intr_params);
 
 		if (q->adaptive_rx) {
diff --git a/drivers/net/ethernet/chelsio/cxgb4/t4_hw.c b/drivers/net/ethernet/chelsio/cxgb4/t4_hw.c
index 660204b..f44d05c 100644
--- a/drivers/net/ethernet/chelsio/cxgb4/t4_hw.c
+++ b/drivers/net/ethernet/chelsio/cxgb4/t4_hw.c
@@ -2634,6 +2634,7 @@ int t4_get_raw_vpd_params(struct adapter *adapter, struct vpd_params *p)
 	if (!vpd)
 		return -ENOMEM;
 
+#ifdef HAVE_PCI_SET_VPD_SIZE
 	/* We have two VPD data structures stored in the adapter VPD area.
 	 * By default, Linux calculates the size of the VPD area by traversing
 	 * the first VPD area at offset 0x0, so we need to tell the OS what
@@ -2642,7 +2643,7 @@ int t4_get_raw_vpd_params(struct adapter *adapter, struct vpd_params *p)
 	ret = pci_set_vpd_size(adapter->pdev, VPD_SIZE);
 	if (ret < 0)
 		goto out;
-
+#endif
 	/* Card information normally starts at VPD_BASE but early cards had
 	 * it at 0.
 	 */
@@ -7379,6 +7380,9 @@ static void set_pcie_completion_timeout(struct adapter *adapter, u8 range)
 	if (pcie_cap) {
 		pci_read_config_word(adapter->pdev,
 				     pcie_cap + PCI_EXP_DEVCTL2, &val);
+#ifdef CONFIG_COMPAT_SLES_12_0
+#define PCI_EXP_DEVCTL2_COMP_TIMEOUT    0x000f
+#endif
 		val &= ~PCI_EXP_DEVCTL2_COMP_TIMEOUT;
 		val |= range;
 		pci_write_config_word(adapter->pdev,
@@ -7851,7 +7855,9 @@ int t4_port_init(struct adapter *adap, int mbox, int pf, int vf)
 			return ret;
 
 		memcpy(adap->port[i]->dev_addr, addr, ETH_ALEN);
+#ifdef HAVE_NET_DEVICE_DEV_PORT
 		adap->port[i]->dev_port = j;
+#endif
 		j++;
 	}
 	return 0;
-- 
1.8.3.1

