From: Steve Wise <swise@opengridcomputing.com>
Subject: [PATCH] cxgb4: backport changes for linux-3.12

Also rename the main cxgb4 backport patch so it will be applied after
the firmware patch to make changing it easier.

Signed-off-by: Steve Wise <swise@opengridcomputing.com>
---
 drivers/net/ethernet/chelsio/cxgb4/cxgb4_main.c |   54 +++++++++++++++++++++++
 drivers/net/ethernet/chelsio/cxgb4/sge.c        |   16 +++++++
 drivers/net/ethernet/chelsio/cxgb4/t4_hw.c      |    2 +
 3 files changed, 72 insertions(+), 0 deletions(-)

diff --git a/drivers/net/ethernet/chelsio/cxgb4/cxgb4_main.c b/drivers/net/ethernet/chelsio/cxgb4/cxgb4_main.c
index xxxxxxx..xxxxxxx xxxxxx
--- a/drivers/net/ethernet/chelsio/cxgb4/cxgb4_main.c
+++ b/drivers/net/ethernet/chelsio/cxgb4/cxgb4_main.c
@@ -71,7 +71,9 @@
 #include "l2t.h"
 #include "t4_firmware.h"
 
+#ifdef HAVE_BONDING_H
 #include <../drivers/net/bonding/bonding.h>
+#endif
 
 #ifdef DRV_VERSION
 #undef DRV_VERSION
@@ -1438,8 +1440,17 @@ static int del_filter_wr(struct adapter *adapter, int fidx)
 	return 0;
 }
 
+#ifdef HAVE_SELECT_QUEUE_FALLBACK_T
 static u16 cxgb_select_queue(struct net_device *dev, struct sk_buff *skb,
 			     void *accel_priv, select_queue_fallback_t fallback)
+#else
+#ifdef NDO_SELECT_QUEUE_HAS_ACCEL_PRIV
+static u16 cxgb_select_queue(struct net_device *dev, struct sk_buff *skb,
+			     void *accel_priv)
+#else
+#endif
+static u16 cxgb_select_queue(struct net_device *dev, struct sk_buff *skb)
+#endif
 {
 	int txq;
 
@@ -1477,7 +1488,11 @@ static u16 cxgb_select_queue(struct net_device *dev, struct sk_buff *skb,
 		return txq;
 	}
 
+#ifdef HAVE_SELECT_QUEUE_FALLBACK_T
 	return fallback(dev, skb) % dev->real_num_tx_queues;
+#else
+	return __netdev_pick_tx(dev, skb) % dev->real_num_tx_queues;
+#endif
 }
 
 static inline int is_offload(const struct adapter *adap)
@@ -3008,6 +3023,7 @@ static int cxgb_set_features(struct net_device *dev, netdev_features_t features)
 	return err;
 }
 
+#ifdef HAVE_GET_SET_RXFH
 static u32 get_rss_table_size(struct net_device *dev)
 {
 	const struct port_info *pi = netdev_priv(dev);
@@ -3036,6 +3052,7 @@ static int set_rss_table(struct net_device *dev, const u32 *p, const u8 *key)
 		return write_rss(pi, pi->rss);
 	return 0;
 }
+#endif
 
 static int get_rxnfc(struct net_device *dev, struct ethtool_rxnfc *info,
 		     u32 *rules)
@@ -3126,9 +3143,11 @@ static const struct ethtool_ops cxgb_ethtool_ops = {
 	.get_wol           = get_wol,
 	.set_wol           = set_wol,
 	.get_rxnfc         = get_rxnfc,
+#ifdef HAVE_GET_SET_RXFH
 	.get_rxfh_indir_size = get_rss_table_size,
 	.get_rxfh	   = get_rss_table,
 	.set_rxfh	   = set_rss_table,
+#endif
 	.flash_device      = set_flash,
 };
 
@@ -4427,20 +4446,30 @@ static int cxgb4_inet6addr_handler(struct notifier_block *this,
 	struct inet6_ifaddr *ifa = data;
 	struct net_device *event_dev;
 	int ret = NOTIFY_DONE;
+#ifdef HAVE_BONDING_H
 	struct bonding *bond = netdev_priv(ifa->idev->dev);
+#ifdef HAVE_BOND_FOR_EACH_SLAVE_3_PARAMS
 	struct list_head *iter;
+#endif
 	struct slave *slave;
 	struct pci_dev *first_pdev = NULL;
+#endif
 
 	if (ifa->idev->dev->priv_flags & IFF_802_1Q_VLAN) {
 		event_dev = vlan_dev_real_dev(ifa->idev->dev);
 		ret = clip_add(event_dev, ifa, event);
 	} else if (ifa->idev->dev->flags & IFF_MASTER) {
+
+#ifdef HAVE_BONDING_H
 		/* It is possible that two different adapters are bonded in one
 		 * bond. We need to find such different adapters and add clip
 		 * in all of them only once.
 		 */
+#ifdef HAVE_BOND_FOR_EACH_SLAVE_3_PARAMS
 		bond_for_each_slave(bond, slave, iter) {
+#else
+		bond_for_each_slave(bond, slave) {
+#endif
 			if (!first_pdev) {
 				ret = clip_add(slave->dev, ifa, event);
 				/* If clip_add is success then only initialize
@@ -4453,6 +4482,10 @@ static int cxgb4_inet6addr_handler(struct notifier_block *this,
 				   to_pci_dev(slave->dev->dev.parent))
 					ret = clip_add(slave->dev, ifa, event);
 		}
+#else
+		netdev_warn(ifa->idev->dev, "offloaded IPv6 and bonding not "
+			    "supported on this kernel\n");
+#endif
 	} else
 		ret = clip_add(ifa->idev->dev, ifa, event);
 
@@ -4463,6 +4496,7 @@ static struct notifier_block cxgb4_inet6addr_notifier = {
 	.notifier_call = cxgb4_inet6addr_handler
 };
 
+
 /* Retrieves IPv6 addresses from a root device (bond, vlan) associated with
  * a physical device.
  * The physical device reference is needed to send the actul CLIP command.
@@ -4508,7 +4542,11 @@ static int update_root_dev_clip(struct net_device *dev)
 	}
 
 	for (i = 0; i < VLAN_N_VID; i++) {
+#ifdef HAVE___VLAN_FIND_DEV_DEEP_RCU
 		root_dev = __vlan_find_dev_deep_rcu(dev, htons(ETH_P_8021Q), i);
+#else
+		root_dev = __vlan_find_dev_deep(dev, htons(ETH_P_8021Q), i);
+#endif
 		if (!root_dev)
 			continue;
 
@@ -6447,9 +6485,25 @@ static int enable_msix(struct adapter *adap)
 #else
 	need = adap->params.nports + EXTRA_VECS + ofld_need;
 #endif
+#ifdef HAVE_PCI_ENABLE_MSIX_RANGE
 	want = pci_enable_msix_range(adap->pdev, entries, need, want);
 	if (want < 0)
 		return want;
+#else
+{
+	int err;
+
+	while ((err = pci_enable_msix(adap->pdev, entries, want)) >= need)
+		want = err;
+
+	if (err) {
+		if (err > 0)
+			dev_info(adap->pdev_dev, "only %d MSI-X vectors left, "
+				 "not using MSI-X\n", err);
+		return err;
+	}
+}
+#endif
 
 	/*
 	 * Distribute available vectors to the various queue groups.
diff --git a/drivers/net/ethernet/chelsio/cxgb4/sge.c b/drivers/net/ethernet/chelsio/cxgb4/sge.c
index xxxxxxx..xxxxxxx xxxxxx
--- a/drivers/net/ethernet/chelsio/cxgb4/sge.c
+++ b/drivers/net/ethernet/chelsio/cxgb4/sge.c
@@ -386,7 +386,11 @@ static void free_tx_desc(struct adapter *adap, struct sge_txq *q,
 		if (d->skb) {                       /* an SGL is present */
 			if (unmap)
 				unmap_sgl(dev, d->skb, d->sgl, q);
+#ifdef HAVE_DEV_CONSUME_SKB_ANY
 			dev_consume_skb_any(d->skb);
+#else
+			dev_kfree_skb_any(d->skb);
+#endif
 			d->skb = NULL;
 		}
 		++d;
@@ -1158,7 +1162,11 @@ out_free:	dev_kfree_skb_any(skb);
 
 	if (immediate) {
 		inline_tx_skb(skb, &q->q, cpl + 1);
+#ifdef HAVE_DEV_CONSUME_SKB_ANY
 		dev_consume_skb_any(skb);
+#else
+		dev_kfree_skb_any(skb);
+#endif
 	} else {
 		int last_desc;
 
@@ -1712,8 +1720,12 @@ static void do_gro(struct sge_eth_rxq *rxq, const struct pkt_gl *gl,
 	skb->ip_summed = CHECKSUM_UNNECESSARY;
 	skb_record_rx_queue(skb, rxq->rspq.idx);
 	if (rxq->rspq.netdev->features & NETIF_F_RXHASH)
+#ifdef HAVE_SKB_SET_HASH
 		skb_set_hash(skb, (__force u32)pkt->rsshdr.hash_val,
 			     PKT_HASH_TYPE_L3);
+#else
+		skb->rxhash = (__force u32)pkt->rsshdr.hash_val;
+#endif
 
 	if (unlikely(pkt->vlan_ex)) {
 		__vlan_hwaccel_put_tag(skb, htons(ETH_P_8021Q), ntohs(pkt->vlan));
@@ -1770,8 +1782,12 @@ int t4_ethrx_handler(struct sge_rspq *q, const __be64 *rsp,
 	skb->protocol = eth_type_trans(skb, q->netdev);
 	skb_record_rx_queue(skb, q->idx);
 	if (skb->dev->features & NETIF_F_RXHASH)
+#ifdef HAVE_SKB_SET_HASH
 		skb_set_hash(skb, (__force u32)pkt->rsshdr.hash_val,
 			     PKT_HASH_TYPE_L3);
+#else
+		skb->rxhash = (__force u32)pkt->rsshdr.hash_val;
+#endif
 
 	rxq->stats.pkts++;
 
diff --git a/drivers/net/ethernet/chelsio/cxgb4/t4_hw.c b/drivers/net/ethernet/chelsio/cxgb4/t4_hw.c
index xxxxxxx..xxxxxxx xxxxxx
--- a/drivers/net/ethernet/chelsio/cxgb4/t4_hw.c
+++ b/drivers/net/ethernet/chelsio/cxgb4/t4_hw.c
@@ -4140,7 +4140,9 @@ int t4_port_init(struct adapter *adap, int mbox, int pf, int vf)
 		p->lport = j;
 		p->rss_size = rss_size;
 		memcpy(adap->port[i]->dev_addr, addr, ETH_ALEN);
+#ifdef HAVE_NET_DEVICE_DEV_PORT
 		adap->port[i]->dev_port = j;
+#endif
 
 		ret = ntohl(c.u.info.lstatus_to_modtype);
 		p->mdio_addr = (ret & FW_PORT_CMD_MDIOCAP) ?
