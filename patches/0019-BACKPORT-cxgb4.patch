From: Steve Wise <swise@opengridcomputing.com>
Subject: [PATCH] BACKPORT: cxgb4

Signed-off-by: Steve Wise <swise@opengridcomputing.com>
---
 drivers/infiniband/hw/cxgb4/cm.c                |   29 +++++++++
 drivers/infiniband/hw/cxgb4/iw_cxgb4.h          |   18 +++++
 drivers/infiniband/hw/cxgb4/mem.c               |    2 +
 drivers/net/ethernet/chelsio/cxgb4/cxgb4_main.c |   76 +++++++++++++++++++++++
 drivers/net/ethernet/chelsio/cxgb4/sge.c        |   28 ++++++++
 drivers/net/ethernet/chelsio/cxgb4/t4_hw.c      |    2 +
 6 files changed, 155 insertions(+), 0 deletions(-)

diff --git a/drivers/infiniband/hw/cxgb4/cm.c b/drivers/infiniband/hw/cxgb4/cm.c
index xxxxxxx..xxxxxxx xxxxxx
--- a/drivers/infiniband/hw/cxgb4/cm.c
+++ b/drivers/infiniband/hw/cxgb4/cm.c
@@ -412,16 +412,24 @@ static struct dst_entry *find_route(struct c4iw_dev *dev, __be32 local_ip,
 				   tos, 0);
 	if (IS_ERR(rt))
 		return NULL;
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(3, 1, 0)
 	n = dst_neigh_lookup(&rt->dst, &peer_ip);
+#else
+	n = dst_get_neighbour(&rt->dst);
+#endif
 	if (!n)
 		return NULL;
 	if (!our_interface(dev, n->dev) &&
 	    !(n->dev->flags & IFF_LOOPBACK)) {
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(3, 1, 0)
 		neigh_release(n);
+#endif
 		dst_release(&rt->dst);
 		return NULL;
 	}
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(3, 1, 0)
 	neigh_release(n);
+#endif
 	return &rt->dst;
 }
 
@@ -1860,7 +1868,11 @@ static int import_ep(struct c4iw_ep *ep, int iptype, __u8 *peer_ip,
 	int err, step;
 	struct net_device *pdev;
 
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(3, 1, 0)
 	n = dst_neigh_lookup(dst, peer_ip);
+#else
+	n = dst_get_neighbour(dst);
+#endif
 	if (!n)
 		return -ENODEV;
 
@@ -1928,7 +1940,9 @@ static int import_ep(struct c4iw_ep *ep, int iptype, __u8 *peer_ip,
 out:
 	rcu_read_unlock();
 
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(3, 1, 0)
 	neigh_release(n);
+#endif
 
 	return err;
 }
@@ -3491,7 +3505,16 @@ static void build_cpl_pass_accept_req(struct sk_buff *skb, int stid , u8 tos)
 	 */
 	memset(&tmp_opt, 0, sizeof(tmp_opt));
 	tcp_clear_options(&tmp_opt);
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(3, 6, 0)
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(3, 9, 0)
 	tcp_parse_options(skb, &tmp_opt, 0, NULL);
+#else
+
+	tcp_parse_options(skb, &tmp_opt, NULL, 0, NULL);
+#endif /* LINUX_VERSION_CODE >= KERNEL_VERSION(3, 9, 0) */
+#else
+	tcp_parse_options(skb, &tmp_opt, NULL, 0);
+#endif /* LINUX_VERSION_CODE >= KERNEL_VERSION(3, 6, 0) */
 
 	req = (struct cpl_pass_accept_req *)__skb_push(skb, sizeof(*req));
 	memset(req, 0, sizeof(*req));
@@ -3660,7 +3683,11 @@ static int rx_pkt(struct c4iw_dev *dev, struct sk_buff *skb)
 		       __func__);
 		goto reject;
 	}
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(3, 1, 0)
 	neigh = dst_neigh_lookup_skb(dst, skb);
+#else
+	neigh = dst_get_neighbour(dst);
+#endif
 
 	if (!neigh) {
 		pr_err("%s - failed to allocate neigh!\n",
@@ -3682,7 +3709,9 @@ static int rx_pkt(struct c4iw_dev *dev, struct sk_buff *skb)
 		pi = (struct port_info *)netdev_priv(pdev);
 		tx_chan = cxgb4_port_chan(pdev);
 	}
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(3, 1, 0)
 	neigh_release(neigh);
+#endif
 	if (!e) {
 		pr_err("%s - failed to allocate l2t entry!\n",
 		       __func__);
diff --git a/drivers/infiniband/hw/cxgb4/iw_cxgb4.h b/drivers/infiniband/hw/cxgb4/iw_cxgb4.h
index xxxxxxx..xxxxxxx xxxxxx
--- a/drivers/infiniband/hw/cxgb4/iw_cxgb4.h
+++ b/drivers/infiniband/hw/cxgb4/iw_cxgb4.h
@@ -297,6 +297,7 @@ static inline int _insert_handle(struct c4iw_dev *rhp, struct idr *idr,
 {
 	int ret;
 
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(3, 9, 0)
 	if (lock) {
 		idr_preload(GFP_KERNEL);
 		spin_lock_irq(&rhp->lock);
@@ -311,6 +312,23 @@ static inline int _insert_handle(struct c4iw_dev *rhp, struct idr *idr,
 
 	BUG_ON(ret == -ENOSPC);
 	return ret < 0 ? ret : 0;
+#else
+	int newid;
+
+	do {
+		if (!idr_pre_get(idr, GFP_KERNEL)) {
+			return -ENOMEM;
+		}
+		if (lock)
+			spin_lock_irq(&rhp->lock);
+		ret = idr_get_new_above(idr, handle, id, &newid);
+		BUG_ON(newid != id);
+		if (lock)
+			spin_unlock_irq(&rhp->lock);
+	} while (ret == -EAGAIN);
+
+	return ret;
+#endif
 }
 
 static inline int insert_handle(struct c4iw_dev *rhp, struct idr *idr,
diff --git a/drivers/infiniband/hw/cxgb4/mem.c b/drivers/infiniband/hw/cxgb4/mem.c
index xxxxxxx..xxxxxxx xxxxxx
--- a/drivers/infiniband/hw/cxgb4/mem.c
+++ b/drivers/infiniband/hw/cxgb4/mem.c
@@ -34,6 +34,8 @@
 #include <linux/moduleparam.h>
 #include <rdma/ib_umem.h>
 #include <linux/atomic.h>
+#include <linux/ratelimit.h>
+#include <linux/printk.h>
 
 #include "iw_cxgb4.h"
 
diff --git a/drivers/net/ethernet/chelsio/cxgb4/cxgb4_main.c b/drivers/net/ethernet/chelsio/cxgb4/cxgb4_main.c
index xxxxxxx..xxxxxxx xxxxxx
--- a/drivers/net/ethernet/chelsio/cxgb4/cxgb4_main.c
+++ b/drivers/net/ethernet/chelsio/cxgb4/cxgb4_main.c
@@ -71,7 +71,9 @@
 #include "l2t.h"
 #include "t4_firmware.h"
 
+#ifdef HAVE_BONDING_H
 #include <../drivers/net/bonding/bonding.h>
+#endif
 
 #ifdef DRV_VERSION
 #undef DRV_VERSION
@@ -1438,8 +1440,17 @@ static int del_filter_wr(struct adapter *adapter, int fidx)
 	return 0;
 }
 
+#ifdef HAVE_SELECT_QUEUE_FALLBACK_T
 static u16 cxgb_select_queue(struct net_device *dev, struct sk_buff *skb,
 			     void *accel_priv, select_queue_fallback_t fallback)
+#else
+#ifdef NDO_SELECT_QUEUE_HAS_ACCEL_PRIV
+static u16 cxgb_select_queue(struct net_device *dev, struct sk_buff *skb,
+			     void *accel_priv)
+#else
+#endif
+static u16 cxgb_select_queue(struct net_device *dev, struct sk_buff *skb)
+#endif
 {
 	int txq;
 
@@ -1477,7 +1488,11 @@ static u16 cxgb_select_queue(struct net_device *dev, struct sk_buff *skb,
 		return txq;
 	}
 
+#ifdef HAVE_SELECT_QUEUE_FALLBACK_T
 	return fallback(dev, skb) % dev->real_num_tx_queues;
+#else
+	return __netdev_pick_tx(dev, skb) % dev->real_num_tx_queues;
+#endif
 }
 
 static inline int is_offload(const struct adapter *adap)
@@ -3008,6 +3023,7 @@ static int cxgb_set_features(struct net_device *dev, netdev_features_t features)
 	return err;
 }
 
+#ifdef HAVE_GET_SET_RXFH
 static u32 get_rss_table_size(struct net_device *dev)
 {
 	const struct port_info *pi = netdev_priv(dev);
@@ -3036,9 +3052,15 @@ static int set_rss_table(struct net_device *dev, const u32 *p, const u8 *key)
 		return write_rss(pi, pi->rss);
 	return 0;
 }
+#endif
 
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(3, 2, 0)
 static int get_rxnfc(struct net_device *dev, struct ethtool_rxnfc *info,
 		     u32 *rules)
+#else
+static int get_rxnfc(struct net_device *dev, struct ethtool_rxnfc *info,
+		     void *rules)
+#endif
 {
 	const struct port_info *pi = netdev_priv(dev);
 
@@ -3126,9 +3148,11 @@ static const struct ethtool_ops cxgb_ethtool_ops = {
 	.get_wol           = get_wol,
 	.set_wol           = set_wol,
 	.get_rxnfc         = get_rxnfc,
+#ifdef HAVE_GET_SET_RXFH
 	.get_rxfh_indir_size = get_rss_table_size,
 	.get_rxfh	   = get_rss_table,
 	.set_rxfh	   = set_rss_table,
+#endif
 	.flash_device      = set_flash,
 };
 
@@ -4427,20 +4451,34 @@ static int cxgb4_inet6addr_handler(struct notifier_block *this,
 	struct inet6_ifaddr *ifa = data;
 	struct net_device *event_dev;
 	int ret = NOTIFY_DONE;
+#ifdef HAVE_BONDING_H
 	struct bonding *bond = netdev_priv(ifa->idev->dev);
+#ifdef HAVE_BOND_FOR_EACH_SLAVE_3_PARAMS
+#ifdef HAVE_BOND_FOR_EACH_SLAVE_3RD_PARAM_IS_INT
+	int iter;
+#else
 	struct list_head *iter;
+#endif
+#endif
 	struct slave *slave;
 	struct pci_dev *first_pdev = NULL;
+#endif
 
 	if (ifa->idev->dev->priv_flags & IFF_802_1Q_VLAN) {
 		event_dev = vlan_dev_real_dev(ifa->idev->dev);
 		ret = clip_add(event_dev, ifa, event);
 	} else if (ifa->idev->dev->flags & IFF_MASTER) {
+
+#ifdef HAVE_BONDING_H
 		/* It is possible that two different adapters are bonded in one
 		 * bond. We need to find such different adapters and add clip
 		 * in all of them only once.
 		 */
+#ifdef HAVE_BOND_FOR_EACH_SLAVE_3_PARAMS
 		bond_for_each_slave(bond, slave, iter) {
+#else
+		bond_for_each_slave(bond, slave) {
+#endif
 			if (!first_pdev) {
 				ret = clip_add(slave->dev, ifa, event);
 				/* If clip_add is success then only initialize
@@ -4453,6 +4491,10 @@ static int cxgb4_inet6addr_handler(struct notifier_block *this,
 				   to_pci_dev(slave->dev->dev.parent))
 					ret = clip_add(slave->dev, ifa, event);
 		}
+#else
+		netdev_warn(ifa->idev->dev, "offloaded IPv6 and bonding not "
+			    "supported on this kernel\n");
+#endif
 	} else
 		ret = clip_add(ifa->idev->dev, ifa, event);
 
@@ -4463,6 +4505,7 @@ static struct notifier_block cxgb4_inet6addr_notifier = {
 	.notifier_call = cxgb4_inet6addr_handler
 };
 
+
 /* Retrieves IPv6 addresses from a root device (bond, vlan) associated with
  * a physical device.
  * The physical device reference is needed to send the actul CLIP command.
@@ -4500,7 +4543,16 @@ static int update_root_dev_clip(struct net_device *dev)
 		return ret;
 
 	/* Parse all bond and vlan devices layered on top of the physical dev */
+#ifdef HAVE_NETDEV_MASTER_UPPER_DEV_GET_RCU
 	root_dev = netdev_master_upper_dev_get_rcu(dev);
+#else
+	if (netif_is_bond_slave(dev)) {
+		root_dev = dev;
+		while (root_dev->master)
+			root_dev = root_dev->master;
+		BUG_ON(root_dev == dev);
+	}
+#endif
 	if (root_dev) {
 		ret = update_dev_clip(root_dev, dev);
 		if (ret)
@@ -4508,7 +4560,15 @@ static int update_root_dev_clip(struct net_device *dev)
 	}
 
 	for (i = 0; i < VLAN_N_VID; i++) {
+#ifdef HAVE___VLAN_FIND_DEV_DEEP_RCU
 		root_dev = __vlan_find_dev_deep_rcu(dev, htons(ETH_P_8021Q), i);
+#else
+#ifdef HAVE__VLAN_FIND_DEV_DEEP_3P
+		root_dev = __vlan_find_dev_deep(dev, htons(ETH_P_8021Q), i);
+#else
+		root_dev = __vlan_find_dev_deep(dev, i);
+#endif
+#endif
 		if (!root_dev)
 			continue;
 
@@ -6447,9 +6507,25 @@ static int enable_msix(struct adapter *adap)
 #else
 	need = adap->params.nports + EXTRA_VECS + ofld_need;
 #endif
+#ifdef HAVE_PCI_ENABLE_MSIX_RANGE
 	want = pci_enable_msix_range(adap->pdev, entries, need, want);
 	if (want < 0)
 		return want;
+#else
+{
+	int err;
+
+	while ((err = pci_enable_msix(adap->pdev, entries, want)) >= need)
+		want = err;
+
+	if (err) {
+		if (err > 0)
+			dev_info(adap->pdev_dev, "only %d MSI-X vectors left, "
+				 "not using MSI-X\n", err);
+		return err;
+	}
+}
+#endif
 
 	/*
 	 * Distribute available vectors to the various queue groups.
diff --git a/drivers/net/ethernet/chelsio/cxgb4/sge.c b/drivers/net/ethernet/chelsio/cxgb4/sge.c
index xxxxxxx..xxxxxxx xxxxxx
--- a/drivers/net/ethernet/chelsio/cxgb4/sge.c
+++ b/drivers/net/ethernet/chelsio/cxgb4/sge.c
@@ -386,7 +386,11 @@ static void free_tx_desc(struct adapter *adap, struct sge_txq *q,
 		if (d->skb) {                       /* an SGL is present */
 			if (unmap)
 				unmap_sgl(dev, d->skb, d->sgl, q);
+#ifdef HAVE_DEV_CONSUME_SKB_ANY
 			dev_consume_skb_any(d->skb);
+#else
+			dev_kfree_skb_any(d->skb);
+#endif
 			d->skb = NULL;
 		}
 		++d;
@@ -615,7 +619,11 @@ static unsigned int refill_fl(struct adapter *adap, struct sge_fl *q, int n,
 
 alloc_small_pages:
 	while (n--) {
+#ifdef HAVE__SKB_ALLOC_PAGE
 		pg = __skb_alloc_page(gfp, NULL);
+#else
+		pg = alloc_page(gfp);
+#endif
 		if (unlikely(!pg)) {
 			q->alloc_failed++;
 			break;
@@ -1158,7 +1166,11 @@ out_free:	dev_kfree_skb_any(skb);
 
 	if (immediate) {
 		inline_tx_skb(skb, &q->q, cpl + 1);
+#ifdef HAVE_DEV_CONSUME_SKB_ANY
 		dev_consume_skb_any(skb);
+#else
+		dev_kfree_skb_any(skb);
+#endif
 	} else {
 		int last_desc;
 
@@ -1712,11 +1724,19 @@ static void do_gro(struct sge_eth_rxq *rxq, const struct pkt_gl *gl,
 	skb->ip_summed = CHECKSUM_UNNECESSARY;
 	skb_record_rx_queue(skb, rxq->rspq.idx);
 	if (rxq->rspq.netdev->features & NETIF_F_RXHASH)
+#ifdef HAVE_SKB_SET_HASH
 		skb_set_hash(skb, (__force u32)pkt->rsshdr.hash_val,
 			     PKT_HASH_TYPE_L3);
+#else
+		skb->rxhash = (__force u32)pkt->rsshdr.hash_val;
+#endif
 
 	if (unlikely(pkt->vlan_ex)) {
+#ifdef HAVE__VLAN_HWACCEL_PUT_TAG_3P
 		__vlan_hwaccel_put_tag(skb, htons(ETH_P_8021Q), ntohs(pkt->vlan));
+#else
+		__vlan_hwaccel_put_tag(skb, ntohs(pkt->vlan));
+#endif
 		rxq->stats.vlan_ex++;
 	}
 	ret = napi_gro_frags(&rxq->rspq.napi);
@@ -1770,8 +1790,12 @@ int t4_ethrx_handler(struct sge_rspq *q, const __be64 *rsp,
 	skb->protocol = eth_type_trans(skb, q->netdev);
 	skb_record_rx_queue(skb, q->idx);
 	if (skb->dev->features & NETIF_F_RXHASH)
+#ifdef HAVE_SKB_SET_HASH
 		skb_set_hash(skb, (__force u32)pkt->rsshdr.hash_val,
 			     PKT_HASH_TYPE_L3);
+#else
+		skb->rxhash = (__force u32)pkt->rsshdr.hash_val;
+#endif
 
 	rxq->stats.pkts++;
 
@@ -1789,7 +1813,11 @@ int t4_ethrx_handler(struct sge_rspq *q, const __be64 *rsp,
 		skb_checksum_none_assert(skb);
 
 	if (unlikely(pkt->vlan_ex)) {
+#ifdef HAVE__VLAN_HWACCEL_PUT_TAG_3P
 		__vlan_hwaccel_put_tag(skb, htons(ETH_P_8021Q), ntohs(pkt->vlan));
+#else
+		__vlan_hwaccel_put_tag(skb, ntohs(pkt->vlan));
+#endif
 		rxq->stats.vlan_ex++;
 	}
 	netif_receive_skb(skb);
diff --git a/drivers/net/ethernet/chelsio/cxgb4/t4_hw.c b/drivers/net/ethernet/chelsio/cxgb4/t4_hw.c
index xxxxxxx..xxxxxxx xxxxxx
--- a/drivers/net/ethernet/chelsio/cxgb4/t4_hw.c
+++ b/drivers/net/ethernet/chelsio/cxgb4/t4_hw.c
@@ -4140,7 +4140,9 @@ int t4_port_init(struct adapter *adap, int mbox, int pf, int vf)
 		p->lport = j;
 		p->rss_size = rss_size;
 		memcpy(adap->port[i]->dev_addr, addr, ETH_ALEN);
+#ifdef HAVE_NET_DEVICE_DEV_PORT
 		adap->port[i]->dev_port = j;
+#endif
 
 		ret = ntohl(c.u.info.lstatus_to_modtype);
 		p->mdio_addr = (ret & FW_PORT_CMD_MDIOCAP) ?
