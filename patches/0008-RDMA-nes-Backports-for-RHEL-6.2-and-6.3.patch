From 62e36abf5a81320929ecdfd96ec15ae7762843f3 Mon Sep 17 00:00:00 2001
From: Tatyana Nikolova <Tatyana.E.Nikolova@intel.com>
Date: Mon, 16 Jul 2012 17:14:31 +0300
Subject: [PATCH 08/25] RDMA/nes: Backports for RHEL 6.2 and 6.3

Backports for linux-3.5 nes to RHEL-6.2 and RHEL-6.3

Signed-off-by: Tatyana Nikolova <Tatyana.E.Nikolova@intel.com>
---
 drivers/infiniband/hw/nes/nes_cm.c  |   12 +++++++++++-
 drivers/infiniband/hw/nes/nes_nic.c |   26 +++++++++++++++++++++++---
 2 files changed, 34 insertions(+), 4 deletions(-)

diff --git a/drivers/infiniband/hw/nes/nes_cm.c b/drivers/infiniband/hw/nes/nes_cm.c
index 020e95c..0b5b1a9 100644
--- a/drivers/infiniband/hw/nes/nes_cm.c
+++ b/drivers/infiniband/hw/nes/nes_cm.c
@@ -1343,9 +1343,16 @@ static int nes_addr_resolve_neigh(struct nes_vnic *nesvnic, u32 dst_ip, int arpi
 	int rc = arpindex;
 	struct net_device *netdev;
 	struct nes_adapter *nesadapter = nesvnic->nesdev->nesadapter;
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(2,6,39))
+	struct flowi fl;
 
+	memset(&fl, 0, sizeof fl);
+	fl.nl_u.ip4_u.daddr = htonl(dst_ip);
+	if (ip_route_output_key(&init_net, &rt, &fl)) {
+#else
 	rt = ip_route_output(&init_net, htonl(dst_ip), 0, 0, 0);
 	if (IS_ERR(rt)) {
+#endif
 		printk(KERN_ERR "%s: ip_route_output_key failed for 0x%08X\n",
 		       __func__, dst_ip);
 		return rc;
@@ -1356,8 +1363,11 @@ static int nes_addr_resolve_neigh(struct nes_vnic *nesvnic, u32 dst_ip, int arpi
 	else
 		netdev = nesvnic->netdev;
 
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(3,1,0))
+	neigh = neigh_lookup(&arp_tbl, &rt->rt_gateway, netdev);
+#else
 	neigh = dst_neigh_lookup(&rt->dst, &dst_ip);
-
+#endif
 	rcu_read_lock();
 	if (neigh) {
 		if (neigh->nud_state & NUD_VALID) {
diff --git a/drivers/infiniband/hw/nes/nes_nic.c b/drivers/infiniband/hw/nes/nes_nic.c
index f3a3ecf..d54776f 100644
--- a/drivers/infiniband/hw/nes/nes_nic.c
+++ b/drivers/infiniband/hw/nes/nes_nic.c
@@ -909,7 +909,11 @@ static void nes_netdev_set_multicast_list(struct net_device *netdev)
 	if (!mc_all_on) {
 		char *addrs;
 		int i;
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,35))
 		struct netdev_hw_addr *ha;
+#else
+		struct dev_mc_list *mcaddr;
+#endif
 
 		addrs = kmalloc(ETH_ALEN * mc_count, GFP_ATOMIC);
 		if (!addrs) {
@@ -917,9 +921,13 @@ static void nes_netdev_set_multicast_list(struct net_device *netdev)
 			goto unlock;
 		}
 		i = 0;
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,35))
 		netdev_for_each_mc_addr(ha, netdev)
 			memcpy(get_addr(addrs, i++), ha->addr, ETH_ALEN);
-
+#else
+		netdev_for_each_mc_addr(mcaddr, netdev)
+			memcpy(get_addr(addrs, i++), mcaddr->dmi_addr, ETH_ALEN);
+#endif
 		perfect_filter_register_address = NES_IDX_PERFECT_FILTER_LOW +
 						pft_entries_preallocated * 0x8;
 		for (i = 0, mc_index = 0; mc_index < max_pft_entries_avaiable;
@@ -1610,6 +1618,7 @@ static void nes_vlan_mode(struct net_device *netdev, struct nes_device *nesdev,
 	spin_unlock_irqrestore(&nesadapter->phy_lock, flags);
 }
 
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,39))
 static netdev_features_t nes_fix_features(struct net_device *netdev, netdev_features_t features)
 {
 	/*
@@ -1635,6 +1644,7 @@ static int nes_set_features(struct net_device *netdev, netdev_features_t feature
 
 	return 0;
 }
+#endif
 
 static const struct net_device_ops nes_netdev_ops = {
 	.ndo_open		= nes_netdev_open,
@@ -1646,8 +1656,10 @@ static const struct net_device_ops nes_netdev_ops = {
 	.ndo_set_rx_mode	= nes_netdev_set_multicast_list,
 	.ndo_change_mtu		= nes_netdev_change_mtu,
 	.ndo_validate_addr	= eth_validate_addr,
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,39))
 	.ndo_fix_features	= nes_fix_features,
 	.ndo_set_features	= nes_set_features,
+#endif
 };
 
 /**
@@ -1711,12 +1723,20 @@ struct net_device *nes_netdev_init(struct nes_device *nesdev,
 	netdev->dev_addr[5] = (u8)u64temp;
 	memcpy(netdev->perm_addr, netdev->dev_addr, 6);
 
+	netdev->features |= NETIF_F_SG | NETIF_F_IP_CSUM;
+
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,39))
 	netdev->hw_features = NETIF_F_RXCSUM | NETIF_F_SG | NETIF_F_IP_CSUM |
 			      NETIF_F_HW_VLAN_RX;
-	if ((nesvnic->logical_port < 2) || (nesdev->nesadapter->hw_rev != NE020_REV))
-		netdev->hw_features |= NETIF_F_TSO;
 	netdev->features |= netdev->hw_features;
 	netdev->hw_features |= NETIF_F_LRO;
+#endif
+	if ((nesvnic->logical_port < 2) || (nesdev->nesadapter->hw_rev != NE020_REV)) {
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,39))
+		netdev->hw_features |= NETIF_F_TSO;
+#endif
+		netdev->features |= NETIF_F_TSO | NETIF_F_GSO;
+	}
 
 	nes_debug(NES_DBG_INIT, "nesvnic = %p, reported features = 0x%lX, QPid = %d,"
 			" nic_index = %d, logical_port = %d, mac_index = %d.\n",
-- 
1.7.9.5

