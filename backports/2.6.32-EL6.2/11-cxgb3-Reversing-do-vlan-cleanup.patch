From 708ed9efefdc11cf5be0491314befb0fafac1daa Mon Sep 17 00:00:00 2001
From: Vipul Pandya <vipul@chelsio.com>
Date: Mon, 7 May 2012 15:50:15 +0530
Subject: [PATCH 03/14] cxgb3: Reversing do vlan cleanup

This patch is a reverse patch of the following upstream commit
892ef5d85259e193505d553c10237fd5dc9a3d0d

Signed-off-by: Vipul Pandya <vipul@chelsio.com>
---
 drivers/net/ethernet/chelsio/cxgb3/adapter.h       |    2 +
 drivers/net/ethernet/chelsio/cxgb3/cxgb3_main.c    |   51 ++++---------------
 drivers/net/ethernet/chelsio/cxgb3/cxgb3_offload.c |    9 ++-
 drivers/net/ethernet/chelsio/cxgb3/sge.c           |   35 +++++++++++--
 4 files changed, 48 insertions(+), 49 deletions(-)

diff --git a/drivers/net/ethernet/chelsio/cxgb3/adapter.h b/drivers/net/ethernet/chelsio/cxgb3/adapter.h
index 8b395b5..7300de5 100644
--- a/drivers/net/ethernet/chelsio/cxgb3/adapter.h
+++ b/drivers/net/ethernet/chelsio/cxgb3/adapter.h
@@ -45,6 +45,7 @@
 #include "t3cdev.h"
 #include <asm/io.h>

+struct vlan_group;
 struct adapter;
 struct sge_qset;
 struct port_info;
@@ -65,6 +66,7 @@ struct iscsi_config {

 struct port_info {
 	struct adapter *adapter;
+	struct vlan_group *vlan_grp;
 	struct sge_qset *qs;
 	u8 port_id;
 	u8 nqsets;
diff --git a/drivers/net/ethernet/chelsio/cxgb3/cxgb3_main.c b/drivers/net/ethernet/chelsio/cxgb3/cxgb3_main.c
index 4d15c8f..d9ee262 100644
--- a/drivers/net/ethernet/chelsio/cxgb3/cxgb3_main.c
+++ b/drivers/net/ethernet/chelsio/cxgb3/cxgb3_main.c
@@ -2531,51 +2531,25 @@ static void t3_synchronize_rx(struct adapter *adap, const struct port_info *p)
 	}
 }

-static void cxgb_vlan_mode(struct net_device *dev, u32 features)
+static void vlan_rx_register(struct net_device *dev, struct vlan_group *grp)
 {
 	struct port_info *pi = netdev_priv(dev);
 	struct adapter *adapter = pi->adapter;

-	if (adapter->params.rev > 0) {
-		t3_set_vlan_accel(adapter, 1 << pi->port_id,
-				  features & NETIF_F_HW_VLAN_RX);
-	} else {
+	pi->vlan_grp = grp;
+	if (adapter->params.rev > 0)
+		t3_set_vlan_accel(adapter, 1 << pi->port_id, grp != NULL);
+	else {
 		/* single control for all ports */
-		unsigned int i, have_vlans = features & NETIF_F_HW_VLAN_RX;
-
+		unsigned int i, have_vlans = 0;
 		for_each_port(adapter, i)
-			have_vlans |=
-				adapter->port[i]->features & NETIF_F_HW_VLAN_RX;
+		    have_vlans |= adap2pinfo(adapter, i)->vlan_grp != NULL;

 		t3_set_vlan_accel(adapter, 1, have_vlans);
 	}
 	t3_synchronize_rx(adapter, pi);
 }

-static u32 cxgb_fix_features(struct net_device *dev, u32 features)
-{
-	/*
-	 * Since there is no support for separate rx/tx vlan accel
-	 * enable/disable make sure tx flag is always in same state as rx.
-	 */
-	if (features & NETIF_F_HW_VLAN_RX)
-		features |= NETIF_F_HW_VLAN_TX;
-	else
-		features &= ~NETIF_F_HW_VLAN_TX;
-
-	return features;
-}
-
-static int cxgb_set_features(struct net_device *dev, u32 features)
-{
-	u32 changed = dev->features ^ features;
-
-	if (changed & NETIF_F_HW_VLAN_RX)
-		cxgb_vlan_mode(dev, features);
-
-	return 0;
-}
-
 #ifdef CONFIG_NET_POLL_CONTROLLER
 static void cxgb_netpoll(struct net_device *dev)
 {
@@ -3156,8 +3130,7 @@ static const struct net_device_ops cxgb_netdev_ops = {
 	.ndo_do_ioctl		= cxgb_ioctl,
 	.ndo_change_mtu		= cxgb_change_mtu,
 	.ndo_set_mac_address	= cxgb_set_mac_addr,
-	.ndo_fix_features	= cxgb_fix_features,
-	.ndo_set_features	= cxgb_set_features,
+	.ndo_vlan_rx_register	= vlan_rx_register,
 #ifdef CONFIG_NET_POLL_CONTROLLER
 	.ndo_poll_controller	= cxgb_netpoll,
 #endif
@@ -3289,8 +3262,9 @@ static int __devinit init_one(struct pci_dev *pdev,
 		netdev->mem_start = mmio_start;
 		netdev->mem_end = mmio_start + mmio_len - 1;
 		netdev->hw_features = NETIF_F_SG | NETIF_F_IP_CSUM |
-			NETIF_F_TSO | NETIF_F_RXCSUM | NETIF_F_HW_VLAN_RX;
-		netdev->features |= netdev->hw_features | NETIF_F_HW_VLAN_TX;
+			NETIF_F_TSO | NETIF_F_RXCSUM;
+		netdev->features |= netdev->hw_features |
+			NETIF_F_HW_VLAN_TX | NETIF_F_HW_VLAN_RX;
 		if (pci_using_dac)
 			netdev->features |= NETIF_F_HIGHDMA;

@@ -3354,9 +3328,6 @@ static int __devinit init_one(struct pci_dev *pdev,
 	err = sysfs_create_group(&adapter->port[0]->dev.kobj,
 				 &cxgb3_attr_group);

-	for_each_port(adapter, i)
-		cxgb_vlan_mode(adapter->port[i], adapter->port[i]->features);
-
 	print_port_info(adapter, ai);
 	return 0;

diff --git a/drivers/net/ethernet/chelsio/cxgb3/cxgb3_offload.c b/drivers/net/ethernet/chelsio/cxgb3/cxgb3_offload.c
index 90ff131..d7cd560 100644
--- a/drivers/net/ethernet/chelsio/cxgb3/cxgb3_offload.c
+++ b/drivers/net/ethernet/chelsio/cxgb3/cxgb3_offload.c
@@ -177,13 +177,16 @@ static struct net_device *get_iff_from_mac(struct adapter *adapter,
 	int i;

 	for_each_port(adapter, i) {
+		struct vlan_group *grp;
 		struct net_device *dev = adapter->port[i];
+		const struct port_info *p = netdev_priv(dev);

 		if (!memcmp(dev->dev_addr, mac, ETH_ALEN)) {
 			if (vlan && vlan != VLAN_VID_MASK) {
-				rcu_read_lock();
-				dev = __vlan_find_dev_deep(dev, vlan);
-				rcu_read_unlock();
+				grp = p->vlan_grp;
+				dev = NULL;
+				if (grp)
+					dev = vlan_group_get_device(grp, vlan);
 			} else if (netif_is_bond_slave(dev)) {
 				while (dev->master)
 					dev = dev->master;
diff --git a/drivers/net/ethernet/chelsio/cxgb3/sge.c b/drivers/net/ethernet/chelsio/cxgb3/sge.c
index cfb60e1..12c3d36 100644
--- a/drivers/net/ethernet/chelsio/cxgb3/sge.c
+++ b/drivers/net/ethernet/chelsio/cxgb3/sge.c
@@ -2028,11 +2028,28 @@ static void rx_eth(struct adapter *adap, struct sge_rspq *rq,
 		skb_checksum_none_assert(skb);
 	skb_record_rx_queue(skb, qs - &adap->sge.qs[pi->first_qset]);

-	if (p->vlan_valid) {
+	if (unlikely(p->vlan_valid)) {
+		struct vlan_group *grp = pi->vlan_grp;
+
 		qs->port_stats[SGE_PSTAT_VLANEX]++;
-		__vlan_hwaccel_put_tag(skb, ntohs(p->vlan));
-	}
-	if (rq->polling) {
+		if (likely(grp))
+			if (lro)
+				vlan_gro_receive(&qs->napi, grp,
+						 ntohs(p->vlan), skb);
+			else {
+				if (unlikely(pi->iscsic.flags)) {
+					unsigned short vtag = ntohs(p->vlan) &
+								VLAN_VID_MASK;
+					skb->dev = vlan_group_get_device(grp,
+									 vtag);
+					cxgb3_process_iscsi_prov_pack(pi, skb);
+				}
+				__vlan_hwaccel_rx(skb, grp, ntohs(p->vlan),
+						  rq->polling);
+			}
+		else
+			dev_kfree_skb_any(skb);
+	} else if (rq->polling) {
 		if (lro)
 			napi_gro_receive(&qs->napi, skb);
 		else {
@@ -2130,8 +2147,14 @@ static void lro_add_page(struct adapter *adap, struct sge_qset *qs,

 	skb_record_rx_queue(skb, qs - &adap->sge.qs[pi->first_qset]);

-	if (cpl->vlan_valid)
-		__vlan_hwaccel_put_tag(skb, ntohs(cpl->vlan));
+	if (unlikely(cpl->vlan_valid)) {
+		struct vlan_group *grp = pi->vlan_grp;
+
+		if (likely(grp != NULL)) {
+			vlan_gro_frags(&qs->napi, grp, ntohs(cpl->vlan));
+			return;
+		}
+	}
 	napi_gro_frags(&qs->napi);
 }

--
1.7.1

